<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Color Palette Generator</title>
    <!-- Add TailwindCSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Tooltip styling */
      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.75);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        transform: translate(-50%, -150%);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .tooltip.visible {
        opacity: 1;
        pointer-events: auto;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800 font-sans">
    <div class="max-w-4xl mx-auto py-10 px-5 flex flex-col gap-4">
      <h1 class="text-xl font-bold text-center">Color Palette Generator</h1>

      <!-- Controls Section -->
      <div class="bg-white shadow-md rounded-lg p-4">
        <div class="flex gap-4 justify-between">
          <div class="mb-4">
            <label for="primaryColor" class="block text-gray-700 font-medium">
              Primary Color:
            </label>
            <input
              type="text"
              id="primaryColor"
              placeholder="#57736A"
              value="#57736A"
              onkeyup="generatePalette()"
              class="w-full border border-gray-300 rounded p-2 mt-1"
            />
          </div>
          <div class="mb-4">
            <label for="secondaryColor" class="block text-gray-700 font-medium"
              >Secondary Color:</label
            >
            <input
              type="text"
              id="secondaryColor"
              placeholder="#8B5CF6"
              value="#8B5CF6"
              onkeyup="generatePalette()"
              class="w-full border border-gray-300 rounded p-2 mt-1"
            />
          </div>
          <div class="mb-4">
            <label for="strategySelect" class="block text-gray-700 font-medium">
              Color Scale Strategy:
            </label>
            <select
              id="strategySelect"
              onchange="generatePalette()"
              class="w-full border border-gray-300 rounded p-2 mt-1"
            >
              <option value="rgb">RGB Luminance (Simple)</option>
              <option value="lab">Perceptual Lightness (LAB)</option>
              <option value="saturation">Lightness + Saturation</option>
              <option value="oklch">OKLCH Lightness (Perceptual)</option>
              <option value="wcag">WCAG Contrast Optimized</option>
              <option value="temperature">
                Temperature Shift (Warm â†” Cool)
              </option>
            </select>
          </div>
        </div>
        <div class="">
          <label for="variantRange" class="block text-gray-700 font-medium">
            Number of Variants: <span id="variantCount">5</span>
          </label>
          <input
            type="range"
            id="variantRange"
            min="1"
            max="15"
            value="5"
            onchange="generatePalette()"
            class="w-full mt-2"
          />
        </div>
        <div class="">
          <label for="lightnessRange" class="block text-gray-700 font-medium">
            Max Lightness (Lighter Shades): <span id="lightnessValue">1.5</span>
          </label>
          <input
            type="range"
            id="lightnessRange"
            min="1.1"
            max="3"
            step="0.1"
            value="1.5"
            onchange="generatePalette()"
            class="w-full mt-2"
          />
        </div>
        <div class="">
          <label for="darknessRange" class="block text-gray-700 font-medium">
            Max Darkness (Darker Shades): <span id="darknessValue">0.5</span>
          </label>
          <input
            type="range"
            id="darknessRange"
            min="0.1"
            max="0.9"
            step="0.1"
            value="0.5"
            onchange="generatePalette()"
            class="w-full mt-2"
          />
        </div>
      </div>

      <!-- Primary Palette Section -->
      <h2 class="text-xl font-bold">Primary Palette</h2>
      <div
        id="primaryPalette"
        class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-4 relative"
      ></div>

      <!-- Secondary Palette Section -->
      <h2 class="text-xl font-bold">Secondary Palette</h2>
      <div
        id="secondaryPalette"
        class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-4 relative"
      ></div>

      <!-- Copy Theme Button -->
      <div class="text-center">
        <button
          id="copyThemeBtn"
          onclick="copyTheme()"
          class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
        >
          Copy Theme JSON
        </button>
      </div>
    </div>

    <script>
      function generateColorVariants(
        primaryHex,
        steps,
        maxLightness,
        maxDarkness,
        strategy
      ) {
        const variants = [];
        const halfSteps = Math.floor((steps - 1) / 2);
        function clamp(v, min = 0, max = 1) {
          return Math.min(max, Math.max(min, v));
        }

        // OKLCH Lightness strategy (approximated via HSL lightness)
        if (strategy === "oklch") {
          const hsl = rgbToHsl(...Object.values(hexToRgb(primaryHex)));
          for (let i = -halfSteps; i <= steps - 1 - halfSteps; i++) {
            const l = clamp(hsl.l + i * ((maxLightness - maxDarkness) / steps));
            const rgb = hslToRgb(hsl.h, hsl.s, l);
            variants.push(rgbToHex(rgb.r, rgb.g, rgb.b));
          }
          return variants.sort(
            (a, b) => getRelativeLuminance(b) - getRelativeLuminance(a)
          );
        }

        // WCAG contrast-optimized scale
        if (strategy === "wcag") {
          const baseRgb = hexToRgb(primaryHex);
          const backgrounds = ["#FFFFFF", "#000000"];

          for (let i = -halfSteps; i <= steps - 1 - halfSteps; i++) {
            let factor = 1 + i * ((maxLightness - maxDarkness) / steps);
            let shade = generateShade(baseRgb, factor);
            let hex = rgbToHex(shade.r, shade.g, shade.b);

            // Adjust until contrast is acceptable
            let attempts = 0;
            while (
              attempts < 10 &&
              Math.min(
                getContrastRatio(hex, backgrounds[0]),
                getContrastRatio(hex, backgrounds[1])
              ) < 4.5
            ) {
              factor *= i < 0 ? 0.95 : 1.05;
              shade = generateShade(baseRgb, factor);
              hex = rgbToHex(shade.r, shade.g, shade.b);
              attempts++;
            }

            variants.push(hex);
          }

          return variants.sort(
            (a, b) => getRelativeLuminance(b) - getRelativeLuminance(a)
          );
        }

        // Temperature-based scale
        if (strategy === "temperature") {
          const hsl = rgbToHsl(...Object.values(hexToRgb(primaryHex)));
          for (let i = -halfSteps; i <= steps - 1 - halfSteps; i++) {
            const t = i / halfSteps;
            const hueShift = t * 15; // degrees
            const l = clamp(hsl.l + t * ((maxLightness - maxDarkness) / 2));
            const rgb = hslToRgb(clamp(hsl.h + hueShift / 360), hsl.s, l);
            variants.push(rgbToHex(rgb.r, rgb.g, rgb.b));
          }
          return variants.sort(
            (a, b) => getRelativeLuminance(b) - getRelativeLuminance(a)
          );
        }

        if (strategy === "rgb") {
          const baseRgb = hexToRgb(primaryHex);

          for (let i = 1; i <= halfSteps; i++) {
            const factor = 1 + i * ((maxLightness - 1) / halfSteps);
            const shade = generateShade(baseRgb, factor);
            variants.unshift(rgbToHex(shade.r, shade.g, shade.b));
          }

          variants.push(primaryHex);

          for (let i = 1; i <= steps - 1 - halfSteps; i++) {
            const factor =
              1 - i * ((1 - maxDarkness) / (steps - 1 - halfSteps));
            const shade = generateShade(baseRgb, factor);
            variants.push(rgbToHex(shade.r, shade.g, shade.b));
          }

          variants.sort(
            (a, b) => getRelativeLuminance(b) - getRelativeLuminance(a)
          );

          return variants;
        }

        const hsl = rgbToHsl(...Object.values(hexToRgb(primaryHex)));

        for (let i = -halfSteps; i <= steps - 1 - halfSteps; i++) {
          let l = hsl.l + i * ((maxLightness - maxDarkness) / steps);
          let s = hsl.s;

          if (strategy === "saturation") {
            const distance = Math.abs(i) / halfSteps;
            s = hsl.s * (1 - 0.3 * distance);
          }

          l = Math.max(0, Math.min(1, l));
          s = Math.max(0, Math.min(1, s));

          const rgb = hslToRgb(hsl.h, s, l);
          variants.push(rgbToHex(rgb.r, rgb.g, rgb.b));
        }

        variants.sort(
          (a, b) => getRelativeLuminance(b) - getRelativeLuminance(a)
        );

        return variants;
      }

      function populatePalette(paletteDiv, colors) {
        paletteDiv.innerHTML = "";
        colors.forEach((color) => {
          const colorBox = document.createElement("div");
          colorBox.className =
            "flex items-center justify-center text-white text-sm font-medium rounded shadow-md h-28 w-28 relative";
          colorBox.style.backgroundColor = color;
          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = color;
          colorInput.className = "absolute inset-0 opacity-0 cursor-pointer";
          colorInput.addEventListener("input", (e) => {
            const newColor = e.target.value.toUpperCase();
            colorBox.style.backgroundColor = newColor;
            span.innerText = newColor;
          });
          const span = document.createElement("span");
          span.className =
            "px-2 py-1 bg-black bg-opacity-50 rounded cursor-pointer";
          span.innerText = color;
          span.addEventListener("click", (e) => {
            e.stopPropagation();
            copyToClipboard(color, span);
          });
          colorBox.appendChild(span);
          colorBox.appendChild(colorInput);
          colorBox.addEventListener("click", () => {
            colorInput.click();
          });
          paletteDiv.appendChild(colorBox);
        });
      }

      function copyToClipboard(color, element) {
        navigator.clipboard.writeText(color).then(
          () => {
            showTooltip(element, "Copied!");
          },
          () => {
            showTooltip(element, "Failed to copy!");
          }
        );
      }

      function showTooltip(element, message) {
        // Remove any existing tooltips
        const existingTooltip = document.querySelector(".tooltip");
        if (existingTooltip) {
          existingTooltip.remove();
        }

        // Create a tooltip element
        const tooltip = document.createElement("div");
        tooltip.className = "tooltip visible";
        tooltip.innerText = message;

        // Position the tooltip
        element.appendChild(tooltip);
        setTimeout(() => tooltip.remove(), 1500);
      }

      function generatePalette() {
        const primaryColor = document.getElementById("primaryColor").value;
        const secondaryColor = document.getElementById("secondaryColor").value;
        const variantSteps = parseInt(
          document.getElementById("variantRange").value,
          10
        );
        const maxLightness = parseFloat(
          document.getElementById("lightnessRange").value
        );
        const maxDarkness = parseFloat(
          document.getElementById("darknessRange").value
        );
        const strategy = document.getElementById("strategySelect").value;

        const primaryColors = generateColorVariants(
          primaryColor,
          variantSteps,
          maxLightness,
          maxDarkness,
          strategy
        );

        const secondaryColors = generateColorVariants(
          secondaryColor,
          variantSteps,
          maxLightness,
          maxDarkness,
          strategy
        );

        populatePalette(
          document.getElementById("primaryPalette"),
          primaryColors
        );
        populatePalette(
          document.getElementById("secondaryPalette"),
          secondaryColors
        );
      }

      function copyTheme() {
        const primaryColor = document.getElementById("primaryColor").value;
        const secondaryColor = document.getElementById("secondaryColor").value;
        const maxLightness = parseFloat(
          document.getElementById("lightnessRange").value
        );
        const maxDarkness = parseFloat(
          document.getElementById("darknessRange").value
        );
        const strategy = document.getElementById("strategySelect").value;

        const primaryColors = generateColorVariants(
          primaryColor,
          5,
          maxLightness,
          maxDarkness,
          strategy
        );
        const secondaryColors = generateColorVariants(
          secondaryColor,
          5,
          maxLightness,
          maxDarkness,
          strategy
        );

        const theme = {
          "primary-lighter": primaryColors[0],
          "primary-light": primaryColors[1],
          primary: primaryColors[2],
          "primary-dark": primaryColors[3],
          "primary-darker": primaryColors[4],
          "secondary-lighter": secondaryColors[0],
          "secondary-light": secondaryColors[1],
          secondary: secondaryColors[2],
          "secondary-dark": secondaryColors[3],
          "secondary-darker": secondaryColors[4],
        };

        const btn = document.getElementById("copyThemeBtn");
        navigator.clipboard.writeText(JSON.stringify(theme, null, 2)).then(
          () => showTooltip(btn, "Theme copied!"),
          () => showTooltip(btn, "Failed to copy!")
        );
      }
      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;

        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }

          h /= 6;
        }

        return { h, s, l };
      }

      function hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
          r = g = b = l;
        } else {
          function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }

          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;

          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }

        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255),
        };
      }

      function hexToRgb(hex) {
        const bigint = parseInt(hex.slice(1), 16);
        return {
          r: (bigint >> 16) & 255,
          g: (bigint >> 8) & 255,
          b: bigint & 255,
        };
      }

      function rgbToHex(r, g, b) {
        return `#${((1 << 24) + (r << 16) + (g << 8) + b)
          .toString(16)
          .slice(1)
          .toUpperCase()}`;
      }

      function getRelativeLuminance(hex) {
        const { r, g, b } = hexToRgb(hex);

        const srgb = [r, g, b].map((v) => {
          v /= 255;
          return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        });

        return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
      }
      function getContrastRatio(hex1, hex2) {
        const L1 = getRelativeLuminance(hex1) + 0.05;
        const L2 = getRelativeLuminance(hex2) + 0.05;
        return Math.max(L1, L2) / Math.min(L1, L2);
      }

      function generateShade(rgb, factor) {
        return {
          r: Math.min(255, Math.max(0, Math.round(rgb.r * factor))),
          g: Math.min(255, Math.max(0, Math.round(rgb.g * factor))),
          b: Math.min(255, Math.max(0, Math.round(rgb.b * factor))),
        };
      }

      // Update sliders dynamically
      document
        .getElementById("variantRange")
        .addEventListener("input", function () {
          document.getElementById("variantCount").innerText = this.value;
        });

      document
        .getElementById("lightnessRange")
        .addEventListener("input", function () {
          document.getElementById("lightnessValue").innerText = this.value;
        });

      document
        .getElementById("darknessRange")
        .addEventListener("input", function () {
          document.getElementById("darknessValue").innerText = this.value;
        });

      document.addEventListener("DOMContentLoaded", generatePalette);
    </script>
  </body>
</html>
